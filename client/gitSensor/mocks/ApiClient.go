// Code generated by mockery v2.20.0. DO NOT EDIT.

package mocks

import (
	context "context"

	gitSensor "github.com/devtron-labs/devtron/client/gitSensor"
	mock "github.com/stretchr/testify/mock"
)

// ApiClient is an autogenerated mock type for the ApiClient type
type ApiClient struct {
	mock.Mock
}

// AddRepo provides a mock function with given fields: ctx, materials
func (_m *ApiClient) AddRepo(ctx context.Context, materials []*gitSensor.GitMaterial) error {
	ret := _m.Called(ctx, materials)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*gitSensor.GitMaterial) error); ok {
		r0 = rf(ctx, materials)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FetchChanges provides a mock function with given fields: ctx, req
func (_m *ApiClient) FetchChanges(ctx context.Context, req *gitSensor.FetchScmChangesRequest) (*gitSensor.MaterialChangeResp, error) {
	ret := _m.Called(ctx, req)

	var r0 *gitSensor.MaterialChangeResp
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gitSensor.FetchScmChangesRequest) (*gitSensor.MaterialChangeResp, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gitSensor.FetchScmChangesRequest) *gitSensor.MaterialChangeResp); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitSensor.MaterialChangeResp)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gitSensor.FetchScmChangesRequest) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAllWebhookEventConfigForHost provides a mock function with given fields: ctx, req
func (_m *ApiClient) GetAllWebhookEventConfigForHost(ctx context.Context, req *gitSensor.WebhookEventConfigRequest) ([]*gitSensor.WebhookEventConfig, error) {
	ret := _m.Called(ctx, req)

	var r0 []*gitSensor.WebhookEventConfig
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gitSensor.WebhookEventConfigRequest) ([]*gitSensor.WebhookEventConfig, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gitSensor.WebhookEventConfigRequest) []*gitSensor.WebhookEventConfig); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitSensor.WebhookEventConfig)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gitSensor.WebhookEventConfigRequest) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCommitMetadata provides a mock function with given fields: ctx, req
func (_m *ApiClient) GetCommitMetadata(ctx context.Context, req *gitSensor.CommitMetadataRequest) (*gitSensor.GitCommit, error) {
	ret := _m.Called(ctx, req)

	var r0 *gitSensor.GitCommit
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gitSensor.CommitMetadataRequest) (*gitSensor.GitCommit, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gitSensor.CommitMetadataRequest) *gitSensor.GitCommit); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitSensor.GitCommit)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gitSensor.CommitMetadataRequest) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCommitMetadataForPipelineMaterial provides a mock function with given fields: ctx, req
func (_m *ApiClient) GetCommitMetadataForPipelineMaterial(ctx context.Context, req *gitSensor.CommitMetadataRequest) (*gitSensor.GitCommit, error) {
	ret := _m.Called(ctx, req)

	var r0 *gitSensor.GitCommit
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gitSensor.CommitMetadataRequest) (*gitSensor.GitCommit, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gitSensor.CommitMetadataRequest) *gitSensor.GitCommit); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitSensor.GitCommit)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gitSensor.CommitMetadataRequest) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetHeadForPipelineMaterials provides a mock function with given fields: ctx, req
func (_m *ApiClient) GetHeadForPipelineMaterials(ctx context.Context, req *gitSensor.HeadRequest) ([]*gitSensor.CiPipelineMaterial, error) {
	ret := _m.Called(ctx, req)

	var r0 []*gitSensor.CiPipelineMaterial
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gitSensor.HeadRequest) ([]*gitSensor.CiPipelineMaterial, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gitSensor.HeadRequest) []*gitSensor.CiPipelineMaterial); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitSensor.CiPipelineMaterial)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gitSensor.HeadRequest) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWebhookData provides a mock function with given fields: ctx, req
func (_m *ApiClient) GetWebhookData(ctx context.Context, req *gitSensor.WebhookDataRequest) (*gitSensor.WebhookAndCiData, error) {
	ret := _m.Called(ctx, req)

	var r0 *gitSensor.WebhookAndCiData
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gitSensor.WebhookDataRequest) (*gitSensor.WebhookAndCiData, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gitSensor.WebhookDataRequest) *gitSensor.WebhookAndCiData); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitSensor.WebhookAndCiData)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gitSensor.WebhookDataRequest) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWebhookEventConfig provides a mock function with given fields: ctx, req
func (_m *ApiClient) GetWebhookEventConfig(ctx context.Context, req *gitSensor.WebhookEventConfigRequest) (*gitSensor.WebhookEventConfig, error) {
	ret := _m.Called(ctx, req)

	var r0 *gitSensor.WebhookEventConfig
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gitSensor.WebhookEventConfigRequest) (*gitSensor.WebhookEventConfig, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gitSensor.WebhookEventConfigRequest) *gitSensor.WebhookEventConfig); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitSensor.WebhookEventConfig)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gitSensor.WebhookEventConfigRequest) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWebhookPayloadDataForPipelineMaterialId provides a mock function with given fields: ctx, req
func (_m *ApiClient) GetWebhookPayloadDataForPipelineMaterialId(ctx context.Context, req *gitSensor.WebhookPayloadDataRequest) (*gitSensor.WebhookPayloadDataResponse, error) {
	ret := _m.Called(ctx, req)

	var r0 *gitSensor.WebhookPayloadDataResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gitSensor.WebhookPayloadDataRequest) (*gitSensor.WebhookPayloadDataResponse, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gitSensor.WebhookPayloadDataRequest) *gitSensor.WebhookPayloadDataResponse); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitSensor.WebhookPayloadDataResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gitSensor.WebhookPayloadDataRequest) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWebhookPayloadFilterDataForPipelineMaterialId provides a mock function with given fields: ctx, req
func (_m *ApiClient) GetWebhookPayloadFilterDataForPipelineMaterialId(ctx context.Context, req *gitSensor.WebhookPayloadFilterDataRequest) (*gitSensor.WebhookPayloadFilterDataResponse, error) {
	ret := _m.Called(ctx, req)

	var r0 *gitSensor.WebhookPayloadFilterDataResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gitSensor.WebhookPayloadFilterDataRequest) (*gitSensor.WebhookPayloadFilterDataResponse, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gitSensor.WebhookPayloadFilterDataRequest) *gitSensor.WebhookPayloadFilterDataResponse); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitSensor.WebhookPayloadFilterDataResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gitSensor.WebhookPayloadFilterDataRequest) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RefreshGitMaterial provides a mock function with given fields: ctx, req
func (_m *ApiClient) RefreshGitMaterial(ctx context.Context, req *gitSensor.RefreshGitMaterialRequest) (*gitSensor.RefreshGitMaterialResponse, error) {
	ret := _m.Called(ctx, req)

	var r0 *gitSensor.RefreshGitMaterialResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *gitSensor.RefreshGitMaterialRequest) (*gitSensor.RefreshGitMaterialResponse, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *gitSensor.RefreshGitMaterialRequest) *gitSensor.RefreshGitMaterialResponse); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitSensor.RefreshGitMaterialResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *gitSensor.RefreshGitMaterialRequest) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SaveGitProvider provides a mock function with given fields: ctx, provider
func (_m *ApiClient) SaveGitProvider(ctx context.Context, provider *gitSensor.GitProvider) error {
	ret := _m.Called(ctx, provider)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *gitSensor.GitProvider) error); ok {
		r0 = rf(ctx, provider)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SavePipelineMaterial provides a mock function with given fields: ctx, ciPipelineMaterials
func (_m *ApiClient) SavePipelineMaterial(ctx context.Context, ciPipelineMaterials []*gitSensor.CiPipelineMaterial) error {
	ret := _m.Called(ctx, ciPipelineMaterials)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*gitSensor.CiPipelineMaterial) error); ok {
		r0 = rf(ctx, ciPipelineMaterials)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateRepo provides a mock function with given fields: ctx, material
func (_m *ApiClient) UpdateRepo(ctx context.Context, material *gitSensor.GitMaterial) error {
	ret := _m.Called(ctx, material)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *gitSensor.GitMaterial) error); ok {
		r0 = rf(ctx, material)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type mockConstructorTestingTNewApiClient interface {
	mock.TestingT
	Cleanup(func())
}

// NewApiClient creates a new instance of ApiClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewApiClient(t mockConstructorTestingTNewApiClient) *ApiClient {
	mock := &ApiClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
